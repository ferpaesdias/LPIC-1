# 101.1 - Identificar e editar configurações de hardware

> Peso 2

## Glossário 
- **BIOS** => Bios Input/Output System
- **UEFI** => Unified Extensible Firmware Interface
- **IRQ** => Interrupt Request line
- **I/O Address** => Input/Output address
- **DMA** => Direct Memory Access
- **PCI** => Peripheral Component Interconnect   
- **USB** => Universal Serial Bus

</br>

## Ativação de dispositivos

Com o utilitário de configuração (o "BIOS") é possível ativar e desativar periféricos integrados, ativar proteção básica contra erros e configurar endereços I/O, IRQ e DMA.

</br>

## Inspeção de dispositivos

O sistema operacional é responsável por associar os componentes de software necessários para a correta operação de cada dispositivo.   
Há 02 maneiras de identificar recursos de hardware:
- Utilizando comandos específicos
- Lendo arquivos dentro de sistemas de arquivos especiais

</br>

## Comandos de Inspeção

- `lspci` => Mostra todos os componentes conectados ao barramento PCI
- `lsusb` => Mostra os dispositivos USB conectados à máquina.

</br>

O comando `lspci` lista os dispositivos PCI:
```shell
lspci                                                    
0000:01:00.1 Audio device: NVIDIA Corporation Device 2291 (rev a1)
0000:2c:00.0 Ethernet controller: Realtek Semiconductor Co., Ltd. RTL8111/8168/8411 PCI Express Gigabit Ethernet Controller (rev 15)
```
Os números hexadecimais no início de cada linha são o endereço exclusivo do dispositivo PCI correspondente. 

</br>

É possível usar a opção `-s`, seguido pelo endereço do dispositivo mais a opção `-v` para mostrar mais detalhes:
```shell
lspci -s 0000:2c:00.0 -v
0000:2c:00.0 Ethernet controller: Realtek Semiconductor Co., Ltd. RTL8111/8168/8411 PCI Express Gigabit Ethernet Controller (rev 15)
	Subsystem: ASUSTeK Computer Inc. RTL8111/8168/8411 PCI Express Gigabit Ethernet Controller
	Flags: bus master, fast devsel, latency 0, IRQ 18, IOMMU group 18
	I/O ports at 3000 [size=256]
	Memory at 60204000 (64-bit, non-prefetchable) [size=4K]
	Memory at 60200000 (64-bit, non-prefetchable) [size=16K]
	Capabilities: [170] Latency Tolerance Reporting
	Capabilities: [178] L1 PM Substates
	Kernel driver in use: r8169
	Kernel modules: r8169
```
O dispositivo acima é um controlador de rede cujo o nome é `Realtek Semiconductor Co., Ltd. RTL8111/8168/8411 PCI Express Gigabit Ethernet Controller`. O item `Subsystem` está associado à marca e modelo do dispositivo `ASUSTeK Computer Inc. RTL8111/8168/8411 PCI Express Gigabit Ethernet Controller`. Na linha `kernel driver in use`identifica o módulo do kernel `r8169`. 

</br>

A opção `-k` do comando `lspci` é outra maneira de verificar qual o módulo está sendo usado para o dispositivo especificado.
```shell
lspci -s 0000:2c:00.0 -k
0000:2c:00.0 Ethernet controller: Realtek Semiconductor Co., Ltd. RTL8111/8168/8411 PCI Express Gigabit Ethernet Controller (rev 15)
	Subsystem: ASUSTeK Computer Inc. RTL8111/8168/8411 PCI Express Gigabit Ethernet Controller
	Kernel driver in use: r8169
	Kernel modules: r8169
```

</br>

O comando `lsusb` mostra os canais USB disponíveis e os dispositivos conectados à eles
```shell
lsusb
Bus 004 Device 002: ID 0bda:0329 Realtek Semiconductor Corp. USB3.0 Card Reader
Bus Device 001: ID 1d6b:0003 Linux Foundation 3.0 root hub
Bus Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub
```
</br>

O comando `lsusb` com a opção `-v` exibe uma saída mais detalhada. Um dispositivo específico pode ser selecionado para inspeção, bastando fornecer seu ID com a opção `-d`:
```shell
lsusb -v -d 1d6b:0002
Bus 003 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub
Device Descriptor:
  bLength                18
  bDescriptorType         1
  bcdUSB               2.00
  bDeviceClass            9 Hub
  bDeviceSubClass         0 
  bDeviceProtocol         1 Single TT
  bMaxPacketSize0        64
  idVendor           0x1d6b Linux Foundation
```

</br>

Com a opção `-t`, o comando `lsusb` mostra os mapeamentos do dispositivo USB na forma de árvore hierárquica: 
```shell
lsusb -t
/:  Bus 04.Port 1: Dev 1, Class=root_hub, Driver=xhci_hcd/4p, 10000M
    |__ Port 2: Dev 2, If 0, Class=Mass Storage, Driver=usb-storage, 5000M
/:  Bus 03.Port 1: Dev 1, Class=root_hub, Driver=xhci_hcd/12p, 480M
    |__ Port 5: Dev 15, If 0, Class=Vendor Specific Class, Driver=, 480M
    |__ Port 8: Dev 3, If 0, Class=Video, Driver=uvcvideo, 480M
    |__ Port 8: Dev 3, If 1, Class=Video, Driver=uvcvideo, 480M
    |__ Port 10: Dev 4, If 0, Class=Wireless, Driver=btusb, 12M
    |__ Port 10: Dev 4, If 1, Class=Wireless, Driver=btusb, 12M
/:  Bus 02.Port 1: Dev 1, Class=root_hub, Driver=xhci_hcd/2p, 20000M/x2
/:  Bus 01.Port 1: Dev 1, Class=root_hub, Driver=xhci_hcd/1p, 480M
```






</br>

Para cada componente de hardware é necessário um componente de software que controla o dispositivo correspondente. Este componente é chamado de **módulo**.

Nem todo dispositivo tem um módulo do kernel associado a ele. A comunicação com certos dispositivos pode ser realizada diretamente pela aplicação.

- `lsmod`=> Lista todos os módulos atualmente carregados.
- `modprobe` => Pode ser utilizado tanto para carregar quanto para descarregar módulos do kernel. 
- `modinfo` => Mostra a descrição, o arquivo, o autor, a licença, a identificação e as dependências.